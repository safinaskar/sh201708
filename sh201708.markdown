UNIX shell coding standard "sh201708"
-

Стандарт для кода, предназначенного для исполнения `/bin/sh`. Не гарантирует портируемости кода. Протестирован только на bash и dash определённых версий.

* Структура скрипта (Весь пункт сделан)
  * `#!/bin/sh`
  * `{`. Здесь нужно открыть фигурную скобку. Закрываться она будет в конце скрипта. Перед закрытием скобки нужно написать `exit 0`. Так нужно, чтобы скрипт можно было редактировать во время выполнения
  * `set -e`
  * Подключение standards support library
  * Константы
  * Парсинг аргументов. Должны поддерживаться `--` и `--help`. Должно проверяться количество операндов. Usage info должен сообщать о поддержке `--`. Usage info должен сообщать о поддержке стандарта
  * Проверить наличие нужных команд (в том числе builtin'ов)
* Структура shell library (Весь пункт сделан)
  * `#!/bin/sh /bin/sh`
  * Комментарий, сообщающий о поддержке стандарта
  * Библиотека не должна ставить `set -e`, т. к. она может быть запущена из интерактивного shell
  * Подключение standards support library
  * Константы
  * Проверить наличие нужных команд (в том числе builtin'ов). Это нужно сделать именно здесь, чтобы сразу же заметить отсутствие нужной команды
* Структура функции
  * Функция, которую будут вызывать извне, и поведение которой зависит от режима `set -e`, должна ставить `set -e`. Но так как она может быть запущена из интерактивного shell, то `set -e` и тело функции должны быть в subshell (Сделано)
  * Парсинг аргументов. Должен поддерживаться `--`. Должно проверяться количество операндов. Для тривиальных функций можно не проверять наличие `--` и не проверять количество операндов. Usage info должен сообщать о поддержке `--`
* О режиме `set -e`
  * Не запускать функции в условии if'а, это переводит их в состояние "неотключаемого `set +e`"
  * Нельзя использовать `$(...)` где либо, кроме присваивания. Нельзя даже `local A="$(...)"`
* Нужно учитывать, что `test` dereferences symlinks и применять `test -L` по необходимости
* При запуске `grep` нужно указывать `--`, т. к. регекс может начинаться с дефиса. Для единообразия у всех команд, которые поддерживают `--`, должен быть указан `--`. Есть команды, которые не поддерживают `--`, поэтому все имена файлов нужно делать безопасными перед использованием с помощью специальной функции из standards support library. Безопасными нужно делать даже имена файлов для команд, поддерживающих `--` (для единообразия). Все переменные, содержащие имена файлов, предполагаются безопасными. Безопасное имя файла предполагается непустым. Если переменная содержит небезопасное имя файла, то имя переменной начинается с `U_`. Если имя безопасно, но может быть пустым, то имя переменной начинается с `E_`. Разумеется, переменные `$1` и тому подобные предполагаются небезопасными (это относится как к аргументам скрипта, так и к аргументам функции). Функции, возвращающие небезопасные имена файлов, должны начинаться с `u_` или `e_`
* Если нужен список сигналов для вызова clean up'а, то нужно использовать список из standards support library
* В dash при получении сигналов не срабатывает `trap EXIT`. Так что нужны trap'ы ещё и для сигналов. Но если в конце обработчика сигнала не поставить `exit`, выхода не произойдёт. Поэтому обработчик сигнала должен заканчиваться на `exit 1`. Пытаться в начале обработчика сигнала сохранить `$?`, а потом сделать `exit` с этим кодом, не получится, т. к. `$?` может оказаться нулём. Нужен именно `exit 1`. В обработчике `EXIT` же `exit 1` писать нельзя. Поэтому для `EXIT` и сигналов должны быть разные обработчики. Поэтому весь clean up помещаем в обработчик `EXIT`, а в обработчике сигналов делаем лишь `exit 1`. Это работает в bash и dash и не приводит к многократному вызову clean up
* echo имеет много недостатков. В целях единообразия всегда используем вместо него printf. В целях единообразия у printf всегда должна быть строка формата
* Помимо всего прочего `A="$(echo *)"; [ "$A" = "*" ]` не работает ещё и потому, что `*` - это разрешённое имя файла
* В названиях переменных используем TEMP, а не TMP
* Лучше, чтобы код был exception safe, это означает, что в случае ошибок и получения сигналов всё корректно чистится. Usage info скрипта должен сообщать, является ли скрипт exception safe. Комментарий в начале shell library должен сообщать, является ли shell library exception safe
* Есть 3 вида сообщений кода: error (default), warning и info (в двух последних случаях должно быть написано warning или info). Все сообщения пишутся в stderr, все они с маленькой буквы (кроме тех случаев, когда мы печатаем готовое чужое сообщение с большой буквы). К usage info эти правила не относятся
* Все переменные должны быть local
* Функция должна сообщать о результате с помощью return'а, а не exit'а. Но, разумеется, если в функции subshell, то из него нужно делать exit, а не return
* Нельзя использовать basename и dirname, нельзя использовать конструкции вида `${A##*/}` вместо них. Нужно использовать только соответствующие функции из standards support library. Использовать `${0##*/}` можно и нужно
* Shell libraries должны экспортировать функции, начинающиеся с некоторого префикса
* Используем слово "файл" ("file"), когда имеется в виду файл в смысле POSIX, т. е. необязательно обычный файл. Если нужно подчеркнуть, что имеется в виду имя файла или путь, говорим "file name"
* Сообщение об ошибке должно содержать имя функции
